# Functions - Public shell functions
# Add machine-specific functions to ~/.local/dotfiles/functions.local

# ------------------------------------------------------------------------------
# Directory Operations
# ------------------------------------------------------------------------------

# Create directory and cd into it
mkcd() {
    mkdir -p "$1" && cd "$1"
}

# ------------------------------------------------------------------------------
# Archive Extraction
# ------------------------------------------------------------------------------

# Universal archive extractor
extract() {
    if [[ -z "$1" ]]; then
        echo "Usage: extract <file>"
        return 1
    fi

    if [[ ! -f "$1" ]]; then
        echo "'$1' is not a valid file"
        return 1
    fi

    case "$1" in
        *.tar.bz2)   tar xjf "$1"    ;;
        *.tar.gz)    tar xzf "$1"    ;;
        *.tar.xz)    tar xJf "$1"    ;;
        *.bz2)       bunzip2 "$1"    ;;
        *.rar)       unrar x "$1"    ;;
        *.gz)        gunzip "$1"     ;;
        *.tar)       tar xf "$1"     ;;
        *.tbz2)      tar xjf "$1"    ;;
        *.tgz)       tar xzf "$1"    ;;
        *.zip)       unzip "$1"      ;;
        *.Z)         uncompress "$1" ;;
        *.7z)        7z x "$1"       ;;
        *.zst)       unzstd "$1"     ;;
        *)           echo "'$1' cannot be extracted via extract()" ;;
    esac
}

# ------------------------------------------------------------------------------
# Search & Navigation
# ------------------------------------------------------------------------------

# Fuzzy cd using fzf (if available)
fcd() {
    local dir
    dir=$(find ${1:-.} -type d 2>/dev/null | fzf +m) && cd "$dir"
}

# Find files by name
ff() {
    find . -type f -iname "*$1*" 2>/dev/null
}

# Find directories by name
fd() {
    find . -type d -iname "*$1*" 2>/dev/null
}

# ------------------------------------------------------------------------------
# Git Helpers
# ------------------------------------------------------------------------------

# Git clone and cd into directory
gclone() {
    git clone "$1" && cd "$(basename "$1" .git)"
}

# Show git branch in current and subdirectories
gbranches() {
    for d in */; do
        if [[ -d "$d/.git" ]]; then
            printf "%-30s %s\n" "$d" "$(git -C "$d" branch --show-current 2>/dev/null)"
        fi
    done
}

# Create a new worktree and branch from within current git directory
unalias gwa 2>/dev/null
gwa() {
    if [[ -z "$1" ]]; then
        echo "Usage: gwa [branch name]"
        return 1
    fi

    local branch="$1"
    local base="$(basename "$PWD")"
    local path="../${base}--${branch}"

    git worktree add -b "$branch" "$path"
    mise trust "$path"
    cd "$path"
}

# Remove worktree and branch from within active worktree directory
unalias gwd 2>/dev/null
gwd() {
    if gum confirm "Remove worktree and branch?"; then
        local cwd base branch root

        cwd="$(pwd)"
        worktree="$(basename "$cwd")"

        # split on first `--`
        root="${worktree%%--*}"
        branch="${worktree#*--}"

        # Protect against accidentally nuking a non-worktree directory
        if [[ "$root" != "$worktree" ]]; then
            cd "../$root"
            git worktree remove "$worktree" --force
            git branch -D "$branch"
        fi
    fi
}

# ------------------------------------------------------------------------------
# Process Management
# ------------------------------------------------------------------------------

# Find process by name
psg() {
    ps aux | grep -v grep | grep -i "$1"
}

# Kill process by port
killport() {
    if [[ -z "$1" ]]; then
        echo "Usage: killport <port>"
        return 1
    fi
    lsof -ti :$1 | xargs kill -9 2>/dev/null || echo "No process on port $1"
}

# ------------------------------------------------------------------------------
# Network
# ------------------------------------------------------------------------------

# Show my public IP
myip() {
    curl -s https://ipinfo.io/ip
    echo
}

# Quick HTTP server
serve() {
    local port="${1:-8000}"
    python3 -m http.server "$port"
}

# ------------------------------------------------------------------------------
# Terminal Theming (Ghostty/iTerm2/WezTerm via OSC sequences)
# ------------------------------------------------------------------------------

# Theme definitions: "name:bg:fg:cursor"
typeset -a TERMINAL_THEMES=(
    "dracula:#282a36:#f8f8f2:#bd93f9"
    "monokai:#272822:#f8f8f2:#f92672"
    "nord:#2e3440:#eceff4:#88c0d0"
    "gruvbox:#282828:#ebdbb2:#fabd2f"
    "solarized:#002b36:#839496:#268bd2"
    "tokyo:#1a1b26:#a9b1d6:#7aa2f7"
    "catppuccin:#1e1e2e:#cdd6f4:#f5e0dc"
    "rose-pine:#191724:#e0def4:#ebbcba"
    "everforest:#2d353b:#d3c6aa:#a7c080"
    "kanagawa:#1f1f28:#dcd7ba:#c8c093"
    "cyberpunk:#0d0d0d:#00ff9f:#ff00ff"
    "ocean:#0a1929:#b2ccd6:#82aaff"
    "ember:#1a0a0a:#ffb4a2:#ff6b35"
    "matrix:#0d1a0d:#00ff00:#00ff00"
    "midnight:#0d0d1a:#c4b5fd:#a78bfa"
)

# Project-to-theme mappings (loaded from ~/.local/dotfiles/projects.local)
# Format: "path_prefix:theme_name:tab_title"
# Example: "/Users/david/projects/suppli:ember:Suppli"
typeset -a PROJECT_THEMES=()

# Track current project theme to avoid re-applying
typeset -g _CURRENT_PROJECT_THEME=""

# Apply theme colors and optionally set tab title
# Usage: _apply_theme <theme_name> [tab_title]
_apply_theme() {
    local theme_name="$1"
    local tab_title="$2"

    # Find theme
    local selected=""
    for t in "${TERMINAL_THEMES[@]}"; do
        if [[ "${t%%:*}" == "$theme_name" ]]; then
            selected="$t"
            break
        fi
    done

    [[ -z "$selected" ]] && return 1

    # Parse: name:bg:fg:cursor
    local rest="${selected#*:}"
    local bg="${rest%%:*}"
    rest="${rest#*:}"
    local fg="${rest%%:*}"
    local cursor="${rest#*:}"

    # Apply colors
    printf '\e]11;%s\a' "$bg"
    printf '\e]10;%s\a' "$fg"
    printf '\e]12;%s\a' "$cursor"

    # Set tab title if provided
    [[ -n "$tab_title" ]] && printf '\e]0;%s\a' "$tab_title"
}

# Reset to default colors and clear title
_reset_theme() {
    printf '\e]111\a\e]110\a\e]112\a\e]104\a'
    printf '\e]0;\a'  # Clear title
    _CURRENT_PROJECT_THEME=""
}

# Hook: auto-apply theme based on current directory
_project_theme_hook() {
    local cwd="$PWD"
    local matched=""

    # Check each project mapping
    for mapping in "${PROJECT_THEMES[@]}"; do
        local path_prefix="${mapping%%:*}"
        local rest="${mapping#*:}"
        local theme_name="${rest%%:*}"
        local tab_title="${rest#*:}"

        # Match if cwd starts with path_prefix
        if [[ "$cwd" == "$path_prefix"* ]]; then
            matched="$mapping"
            break
        fi
    done

    if [[ -n "$matched" ]]; then
        # Avoid re-applying same theme
        [[ "$_CURRENT_PROJECT_THEME" == "$matched" ]] && return

        local rest="${matched#*:}"
        local theme_name="${rest%%:*}"
        local tab_title="${rest#*:}"

        _apply_theme "$theme_name" "$tab_title"
        _CURRENT_PROJECT_THEME="$matched"
    elif [[ -n "$_CURRENT_PROJECT_THEME" ]]; then
        # Left a project directory, reset
        _reset_theme
    fi
}

# Register the hook
autoload -Uz add-zsh-hook
add-zsh-hook chpwd _project_theme_hook

# Change terminal color scheme dynamically
# Usage: theme [name|--list|--reset]
# No args = random theme
theme() {
    case "$1" in
        --list|-l)
            echo "Available themes:"
            for t in "${TERMINAL_THEMES[@]}"; do
                echo "  ${t%%:*}"
            done
            return 0
            ;;
        --reset|-r)
            _reset_theme
            echo "Colors reset to default"
            return 0
            ;;
        "")
            # Random theme
            local idx=$((RANDOM % ${#TERMINAL_THEMES[@]} + 1))
            local selected="${TERMINAL_THEMES[$idx]}"
            local name="${selected%%:*}"
            _apply_theme "$name"
            echo "Theme: $name"
            ;;
        *)
            if _apply_theme "$1"; then
                echo "Theme: $1"
            else
                echo "Unknown theme: $1"
                echo "Use 'theme --list' to see available themes"
                return 1
            fi
            ;;
    esac
}
